/*
 * Copyright 2011, Blender Foundation.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include "util_progress.h"
#include "blender_session.h"


OCT_NAMESPACE_BEGIN

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Progress::Progress() {
    cur_samples     = 0;
    start_time      = time_dt();
    total_time      = 0.0f;
    status          = "Initializing";
    substatus       = "";
    sync_status     = "";
    sync_substatus  = "";
    cancel          = false;
    cancel_message  = "";
    blender_session = 0;
} //Progress()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CONSTRUCTOR
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Progress::Progress(Progress& progress) {
    *this = progress;
} //Progress(...)

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set the current blender session
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_blender_session(BlenderSession* const session) {
    thread_scoped_lock lock(progress_mutex);
    blender_session = session;
} //set_blender_session()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Tell blender we want to redraw
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_update() {
    if(blender_session) {
        thread_scoped_lock lock(update_mutex);
        blender_session->tag_redraw();
    }
} //set_update()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get current progress status
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::get_status(string& status_, string& substatus_) {
    thread_scoped_lock lock(progress_mutex);

    if(sync_status != "") {
        status_     = sync_status;
        substatus_  = sync_substatus;
    }
    else {
        status_     = status;
        substatus_  = substatus;
    }
} //get_status()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_sync_substatus(const string& substatus_) {
    {
        thread_scoped_lock lock(progress_mutex);
        sync_substatus  = substatus_;
        total_time      = time_dt() - start_time;
    }
    set_update();
} //set_sync_substatus()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_sync_status(const string& status_, const string& substatus_) {
    {
        thread_scoped_lock lock(progress_mutex);
        sync_status     = status_;
        sync_substatus  = substatus_;
        total_time      = time_dt() - start_time;
    }
    set_update();
} //set_sync_status()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_substatus(const string& substatus_) {
    {
        thread_scoped_lock lock(progress_mutex);
        substatus   = substatus_;
        total_time  = time_dt() - start_time;
    }
    set_update();
} //set_substatus()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_status( const string& status_, const string& substatus_) {
    {
        thread_scoped_lock lock(progress_mutex);
        status      = status_;
        substatus   = substatus_;
        total_time  = time_dt() - start_time;
    }
    set_update();
} //set_status()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Progress::get_cur_samples() {
    return cur_samples;
} //get_cur_samples()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set current rendered samples count
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_cur_samples(unsigned long cur_samples) {
    thread_scoped_lock lock(progress_mutex);
    cur_samples = cur_samples;
} //set_cur_samples()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Reset current rendered samples count
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::reset_cur_samples() {
    thread_scoped_lock lock(progress_mutex);
    cur_samples = 0;
} //reset_cur_samples()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get total render time
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::get_time(double& total_time_) {
    thread_scoped_lock lock(progress_mutex);
    total_time_ = (total_time > 0.0) ? total_time : 0.0;
} //get_time()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set current progress info
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::refresh_cur_info() {
    thread_scoped_lock lock(progress_mutex);
    total_time = time_dt() - start_time;
} //refresh_cur_info()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_start_time(double start_time_) {
    thread_scoped_lock lock(progress_mutex);
    start_time = start_time_;
} //set_start_time()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
string Progress::get_cancel_message() {
    thread_scoped_lock lock(progress_mutex);
    return cancel_message;
} //get_cancel_message()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Test if we need to cancel
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Progress::get_cancel() {
    if(!cancel && blender_session) blender_session->test_cancel();
    return cancel;
} //get_cancel()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Set we need to cancel
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Progress::set_cancel(const string& cancel_message_) {
    thread_scoped_lock lock(progress_mutex);
    cancel_message  = cancel_message_;
    cancel          = true;
} //set_cancel()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Progress& Progress::operator=(Progress& progress) {
    thread_scoped_lock lock(progress.progress_mutex);

    progress.get_status(status, substatus);
    progress.get_time(total_time);

    cur_samples = progress.get_cur_samples();

    return *this;
} //operator=()

OCT_NAMESPACE_END
