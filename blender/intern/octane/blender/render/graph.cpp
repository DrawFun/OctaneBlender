/*
 * Copyright 2011, Blender Foundation.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include "graph.h"
#include "nodes.h"

OCT_NAMESPACE_BEGIN

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderInput::ShaderInput(ShaderNode *parent_, const char *name_, ShaderSocketType type_) {
	parent          = parent_;
	name            = name_;
	type            = type_;
	link            = NULL;
	value           = make_float3(0, 0, 0);
} //ShaderInput()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderOutput::ShaderOutput(ShaderNode *parent_, const char *name_, ShaderSocketType type_) {
	parent  = parent_;
	name    = name_;
	type    = type_;
} //ShaderOutput()



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode::ShaderNode(const char *name_) {
	name    = name_;
	id      = -1;
} //ShaderNode()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode::~ShaderNode() {
    vector<ShaderInput*>::iterator it_in;
    for(it_in = inputs.begin(); it_in != inputs.end(); ++it_in)
		delete *it_in;

    vector<ShaderOutput*>::iterator it_out;
    for(it_out = outputs.begin(); it_out != outputs.end(); ++it_out)
		delete *it_out;
} //~ShaderNode()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderInput *ShaderNode::input(const char *name) {
    vector<ShaderInput*>::iterator it;
    for(it = inputs.begin(); it != inputs.end(); ++it) {
        ShaderInput *socket = *it;
		if(strcmp(socket->name, name) == 0)
			return socket;
    }
	return 0;
} //input()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderOutput *ShaderNode::output(const char *name) {
    vector<ShaderOutput*>::iterator it;
    for(it = outputs.begin(); it != outputs.end(); ++it) {
        ShaderOutput *socket = *it;
		if(strcmp(socket->name, name) == 0)
			return socket;
    }
	return 0;
} //output()



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderGraph::ShaderGraph() {
} //ShaderGraph()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderGraph::~ShaderGraph() {
    list<ShaderNode*>::iterator it;
    for(it = nodes.begin(); it != nodes.end(); ++it)
		delete *it;
} //~ShaderGraph()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode *ShaderGraph::add(ShaderNode *node) {
	node->id = nodes.size();
	nodes.push_back(node);
	return node;
} //add()

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ShaderNode *ShaderGraph::output() {
    if(nodes.empty()) return 0;
    else return nodes.front();
} //output()

OCT_NAMESPACE_END

